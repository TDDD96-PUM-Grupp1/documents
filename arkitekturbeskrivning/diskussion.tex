\section{Diskussion}
Arkitekturen lägger stor tilltro till att vissa komponenter klarar av uppgifter effektivt. Speciellt komponenten IoT-Backend är central för systemets responsivitet, då all data mellan UI- och kontroll-applikation går genom denna. Här finns också begränsad möjlighet till optimering, då den till stor del består av ett redan existerande system som ej kan modifieras.\\

Det finns stora utmaningar gällande utformningen av gränssnittet mellan spellägen och spelet. Att få gränssnittet både väldefinierat och brett kräver en noggrann och välgrundad design. Med den valda strukturen i figur \ref{fig:implementationsarkitektur-UI} är förhoppningen att detta kan uppnås. Detta gränssnitt kan också med fördel uppdateras då man får en bättre bild av de spellägen som ska implementeras.\\

Arkitekturens användargränssnitt har fler ansvarsområden än att endast visa upp saker. Dessa innefattar främst logik som ligger nära utritning av grafik och menyer. Denna logik är dock mycket enkel och har liten påverkan på resten av systemet. Här lämpar sig React som bibliotek mycket bra för att hålla både grafiska komponenter och viss logik strukturerad. Om denna logik i framtiden skulle växa kan det finnas ett värde i att bryta ut den till egna komponenter.\\

Spelets kontroller i kontroll-applikationen kan i framtiden generaliseras. För att tillåta andra styrningsmetoder än sensorer kan flera komponenter behöva skapas. Dessa bör struktureras så att oavsett hur användaren kontrollerar spelet blir den slutgiltiga datan som skickas till UI-komponenten densamma.\\

I tidigare förslag till arkitekturen fanns endast resurs-servern på UI-delen av systemet. Då funktionalitet för att visa upp spelinformation och grafik även på kontroll-applikationen diskuterades blev det tydligt att en till resurs-server placerad i kontroll-applikationen kunde vara nyttig. Detta tillägg ansågs inte ge en negativ påverkan på arkitekturen för kontroll-applikationen.\\

När arkitekturen utarbetades såg till en början stora delar av strukturen i UI-applikationen annorlunda ut. Arkitekturen var uppdelad i flera lager med ett större fokus på kommunikation mellan spelet och applikationens menyer. När use-cases började studeras blev det dock tydligt att många komponenter var mycket nära ihopkopplade. Detta löstes genom att fokuset lades om till endast spelet som den centrala komponenten i UI-applikationen. När de andra komponenterna placerades runt denna uppkom en struktur som var både tydligare och visade på bättre informationsvägar.\\

Flera olika lösningar har diskuterats för hur spelläget ska kommunicera med grundspelet. En alternativ idé som togs upp var att låta all spelar-input passera genom spellägeskomponenten. Detta gav dock viss svårighet i att föra spelet framåt baserat på tillståndet. Slutsatsen från denna diskussion blev ett samband mellan spellägets moduläritet, gränssnittets storlek och spellägets möjligheter till kontroll över spelet. Om man vill tillåta stor påverkan från spelläget måste antingen gränssnittet växa eller så kommer spelläget att få en närmare, mindre modulär, koppling till spelet. Den lösning som ansågs bäst för att behålla moduläritet, men även tillåta stor påverkan från spelläget, var att definiera ett stort gränssnitt som i sig är nära kopplat till många komponenter i spelet. Ett stort, komplext gränssnitt sågs som en godtagbar uppoffring eftersom detta ändå ger en bra möjlighet att bibehålla struktur i arkitekturen.\\

En annan utveckling på idén med spellägen som diskuterades var en ännu mer modulär design, där all spellogik tillfördes som nya spellägen till spelets tillstånd. I denna variant skulle fysiken och den grundläggande spelmekaniken kunna vara modulära spellägen. Detta skulle självklart kräva att ett godtyckligt antal spellägen kunde användas samtidigt. Det stora problemet som gjorde att denna lösning skrotades var insikten att dessa spellägen också skulle behöva interagera med varandra. Exempelvis kan spellogik behöva köras efter specifika fysikhändelser. Komplexiteten som introducerades av detta ansågs onödig för de spel som är planerade att skapas. En annan lösning som föreslogs var att bygga spellägen med arv av egenskaper och funktionalitet. Exempelvis skulle grundläggande spelmekanik kunna vara ett spelläge som andra lägen kunde ärva från och utveckla. Dock ansågs denna idé också onödigt komplex för de spel som planerades implementeras.\\

Mycket undersökning har gjorts om använding av färdiga bibliotek för att underlätta utvecklingen av speldelen av systemet. Frågor som har undersökts är till vilken grad färdiga bibliotek bör användas och vilka bibliotek som i så fall skulle passa för detta system. Den lösning som har tagits fram är att använda biblioteket PixiJS\cite{bib-pixi} för rendering av grafik och sedan bygga den fysik som krävs. Andra alternativ som har övervägts är fullskaliga spelbibliotek eller använding av något bibliotek även för fysiken. Dessa stora paket ansågs onödigt tunga för de spel som ska skapas. Att bygga komponenterna ger även större kontroll över deras beteenden och underlättar integration med de existerande bibliotek som används i systemet.\\

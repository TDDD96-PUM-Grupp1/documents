\section{Resultat}
\label{sec:david-results}
Det här kapitlet går igenom resultatet utav studien.

\subsection{Speltestning}
Det finns många sätt att automatisera speltester på, men många saker som fortfarande kräver mänsklig interaktion. Tester automatiseras till stor del i början av utvecklingsfasen för regressionstestning, ett sätt att testa att det som fungerar i en tidigare utgåva, även fungerar i en senare. Exempel på detta kan vara Snapshot\ref{sec:david-theory}. Ett annat stort användningsområde inom automatisk testning är att man kan utföra tester som inte går att göra manuellt utan stora kostnader. Att använda automatisering till att simulera flera användare, kanske hundratals att använda produkten samtidigt för att utföra stresstester eller prestandatester är ett sånt exempel. \cite{book-sta}

Mycket när det kommer till spel är själva känslan utav spelet. Det är svårt att kvantifiera och därför brukar större företag släppa tidigare versioner utav spel för att se hur allmänheten tycker om spelet i sig, så kallade beta-versioner \cite{bib-beta-version-testing}. Projektgruppen skapade även en egen beta-version. I vår version höll vi en kort presentation och visade personerna hur man styrde. Efter det lät vi dem koppla upp sig till ett lokalt nätverk och ansluta till en lokal server för att gå med i spelet. Efter att de spelat i ett par minuter bad vi dem fylla i ett formulär med frågor om vad de tyckte om produkten. Som testledare tyckte jag att det var intressant att se hur de olika mobilerna folk använde sig utav fick applikationen att se annorlunda ut och gjorde att spelupplevelsen varierade lite på vissa telefoner.

Då tiden är begränsad gäller det att testa så effektivt som möjligt och hur man gör det är en ständig fråga \cite{bib-testing-time}. Att göra ett stort test som testar allting kan gå snabbare, men det hjälper inte så mycket då ifall testet misslyckas får man inte ut så mycket information om felet. Att göra många små test är tidskrävande men mycket mer effektivt. Mycket automatisk testning sker regressivt, det handlar om att skriva tester som kollar att funktionaliteten fungerar även i framtiden då koden kan ha blivit modifierad. Om man gör exempelvis en meny till ett spel och den är färdig, kan man ta en snapshot på menyn. Om man skulle råka modifiera någon av parametrarna så menyn fortfarande kompilerar kommer jämförelsen med en tidigare snapshot upptäcka det och fråga om ändringen var medveten. Hade samma test utförts med hjälp av assertion tests skulle det vara fantastiskt många rader kod. Det handlar om att använda rätt test för rätt tillfälle.

\subsection{Testverktyg}
Tyvärr är det ju så att det inte finns ett perfekt verktyg som alltid är bäst att använda. Däremot finns det fördelar och nackdelar med de olika verktygen så man lättare kan veta när man ska välja vad för verktyg för sina tester. Till exempel, vi valde att utveckla vårt spel i React, och därför var Jest ett bra alternativ då det parallellutvecklades med React. 

Jest är bra för att det är snabbt att komma igång och börja arbeta direkt, till skillnad från flera andra bibliotek har det ett brett API som inte kräver att man inkluderar extra bibliotek om man inte absolut behöver det. Jest utnyttjar även något som kallas för workers \cite{bib-jest-worker}, de används för att optimera testningen genom att låta test köras parallellt vilket kan öka hastigheten enormt vid större projekt. Jest är baserat på Jasmine och har mycket av dess funktionalitet men med har utökat den. De har till exempel lagt till bättre mock-funktionalitet och förbättrat funktionaliteten så att tester kan köras parallellt. En nackdel med Jest är att det är nyare och inte funnits lika länge som Mocha och skaffat sig samma användarbas. Det påverkar användarskapade bibliotek och kan innebära mindre varierande funktionalitet och potentiellt fler oupptäckta buggar. 